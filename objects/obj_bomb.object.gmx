<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_bomb</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize

step=0
grav = 0.8
startDeath=false
horFriction=0.99
verFriction=0.99

verMulti = 12
horMulti = 12
useFrictionx = 1
useFrictiony = 1
maxDist = 300
time = 0

horSpeed = 0
verSpeed = 0
horFrac = 0
verFrac = 0
horSpeedStore = 0
verSpeedStore = 0

verDistance = 0
horDistance = 0

bounceWeight = 0.7

inLaunch = false
lineWidth = 0
inDeath = false
startX = x
startY = y

aboveFree = false
belowFree = false
leftFree = false
rightFree = false
launchDone = true
aboveJump = false
belowJump = false
leftJump = false
rightJump = false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Info
if (place_meeting(x, y + 1, obj_parentWall)) {
    belowFree = false
}
else {
    belowFree = true
}
if (place_meeting(x, y - 1, obj_parentWall)) {
    aboveFree = false
}
else {
    aboveFree = true
}
if (place_meeting(x + 1, y, obj_parentWall)) {
    rightFree = false
}
else {
    rightFree = true
}
if (place_meeting(x - 1, y, obj_parentWall)) {
    leftFree = false
}
else {
    leftFree = true
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Bomb

step++

if (step==90)
{
    if(collision_circle(x, y, 64, obj_parentWall, true, false) != noone) {
        surface_set_target(obj_surControl.terrain)
        draw_set_blend_mode(bm_subtract)
        draw_circle_colour(x,y-272,64,c_white,c_white,false)
        draw_set_blend_mode(bm_normal)
        surface_reset_target()
        
        sprite_delete(obj_surControl.spr_terrain)
        obj_surControl.spr_terrain = sprite_create_from_surface(obj_surControl.terrain,0,0,1024,512,false,false,0,0)
        sprite_collision_mask(obj_surControl.spr_terrain,false,0,0,0,0,0,0,0)
        obj_surControl.sprite_index = obj_surControl.spr_terrain
    }
    instance_create(x,y,obj_boom)
    instance_destroy()
    
}


for(i=0;i&lt;instance_number(obj_boom);i++)
{
    currentboom=instance_find(obj_boom,i)
    var dis=point_distance(x,y,currentboom.x,currentboom.y)
    if(dis&lt;64) {
        rforce=-(30/power(dis,0.5))
        if((rforce/2)&lt;-0.5) {
            horSpeed += lengthdir_x(rforce,point_direction(x,y,currentboom.x,currentboom.y))
            verSpeed += lengthdir_y(rforce,point_direction(x,y,currentboom.x,currentboom.y))
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Collisions

verFrac+=frac(verSpeed)
verDistance=verSpeed
if abs(verFrac)&gt;=1
{
    verDistance+=sign(verFrac)
    verFrac-=sign(verFrac)
}

for(v=1; v&lt;=floor(abs(verDistance)); v++)
{
    if(!place_meeting(x,y+sign(verSpeed),obj_parentWall))
    {
        y+=sign(verSpeed)
        v++
    } 
    else
    {
        if(abs(verSpeed)*abs(horSpeed) &gt; 400)
        {
            if(collision_circle(x, y, 64, obj_parentWall, true, false) != noone) {
                surface_set_target(obj_surControl.terrain)
                draw_set_blend_mode(bm_subtract)
                draw_circle_colour(x,y-272,64,c_white,c_white,false)
                draw_set_blend_mode(bm_normal)
                surface_reset_target()
                
                sprite_delete(obj_surControl.spr_terrain)
                obj_surControl.spr_terrain = sprite_create_from_surface(obj_surControl.terrain,0,0,1024,512,false,false,0,0)
                sprite_collision_mask(obj_surControl.spr_terrain,false,0,0,0,0,0,0,0)
                obj_surControl.sprite_index = obj_surControl.spr_terrain
            }
            instance_create(x,y,obj_boom)
            instance_destroy()
        }
        else {
            if (verSpeed * bounceWeight &lt;= 5) {
                verSpeed = 0
            }
            else {
                verSpeed=-verSpeed*bounceWeight
            }
        }
    }
}

horFrac+=frac(horSpeed)
horDistance=horSpeed
if abs(horFrac)&gt;=1
{
    horDistance+=sign(horFrac)
    horFrac-=sign(horFrac)
}
    
for(h=1; h&lt;=floor(abs(horDistance)); h++)
{
    if(!place_meeting(x+sign(horSpeed),y,obj_parentWall))
    {
    x+=sign(horSpeed)
    h++
    }
    else
    {
    if(abs(verSpeed)*abs(horSpeed) &gt; 400)
        {
            if(collision_circle(x, y, 64, obj_parentWall, true, false) != noone) {
                surface_set_target(obj_surControl.terrain)
                draw_set_blend_mode(bm_subtract)
                draw_circle_colour(x,y-272,64,c_white,c_white,false)
                draw_set_blend_mode(bm_normal)
                surface_reset_target()
                
                sprite_delete(obj_surControl.spr_terrain)
                obj_surControl.spr_terrain = sprite_create_from_surface(obj_surControl.terrain,0,0,1024,512,false,false,0,0)
                sprite_collision_mask(obj_surControl.spr_terrain,false,0,0,0,0,0,0,0)
                obj_surControl.sprite_index = obj_surControl.spr_terrain
            }
            instance_create(x,y,obj_boom)
            instance_destroy()
        }
        else {
            if (horSpeed * bounceWeight &lt;= 5) {
                horSpeed = 0
            }
            else {
                horSpeed=-horSpeed*bounceWeight
            }
        }
    }
}

if(place_free(x,y+1)&amp;&amp;verSpeed&lt;=32)
{
verSpeed+=grav
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Friction

useFrictiony=1
useFrictionx=1

if(!place_free(x,y+1))
{
    useFrictionx=useFrictionx*instance_place(x,y+1,obj_parentWall).horFriction
}
if(!place_free(x,y-1))
{
    useFrictionx=useFrictionx*instance_place(x,y-1,obj_parentWall).horFriction
}
if(!place_free(x+1,y))
{
    useFrictiony=useFrictiony*instance_place(x+1,y,obj_parentWall).verFriction
}
if(!place_free(x-1,y))
{
    useFrictiony=useFrictiony*instance_place(x-1,y,obj_parentWall).verFriction
}

horSpeed=horSpeed*useFrictionx
verSpeed=verSpeed*useFrictiony

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
